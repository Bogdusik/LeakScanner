package com.leakscanner.service;

import com.leakscanner.dto.RepositoryDTO;
import com.leakscanner.model.Vulnerability;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class VulnerabilityScannerService {
    
    private final GitHubService githubService;
    private final GitLabService gitLabService;
    private final NpmAuditService npmAuditService;
    private final SnykService snykService;
    
    @Value("${leakscanner.api.snyk.base-url:https://api.snyk.io/v1}")
    private String snykBaseUrl;
    
    public List<Vulnerability> scanForVulnerabilities(
            RepositoryDTO repositoryDTO,
            String githubToken,
            String gitlabToken,
            String snykToken
    ) {
        log.info("Scanning for vulnerabilities in {}: {}/{}", 
                repositoryDTO.getPlatform(), repositoryDTO.getOwner(), repositoryDTO.getName());
        
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            // Get package.json, pom.xml, or requirements.txt
            String packageJson = getPackageFileContent(repositoryDTO, "package.json", githubToken, gitlabToken);
            getPackageFileContent(repositoryDTO, "pom.xml", githubToken, gitlabToken); // Check for Maven projects
            getPackageFileContent(repositoryDTO, "requirements.txt", githubToken, gitlabToken); // Check for Python projects
            
            // Scan with npm audit
            if (packageJson != null) {
                vulnerabilities.addAll(npmAuditService.scanPackageJson(packageJson));
            }
            
            // Scan with Snyk if token provided
            if (snykToken != null && !snykToken.isEmpty()) {
                vulnerabilities.addAll(snykService.scanRepository(repositoryDTO, snykToken));
            }
            
            // Check for common security issues in code
            vulnerabilities.addAll(scanForCodeVulnerabilities(repositoryDTO, githubToken, gitlabToken));
            
        } catch (Exception e) {
            log.error("Error scanning for vulnerabilities", e);
        }
        
        return vulnerabilities;
    }
    
    private String getPackageFileContent(RepositoryDTO repositoryDTO, String fileName, String githubToken, String gitlabToken) {
        try {
            if ("github".equalsIgnoreCase(repositoryDTO.getPlatform())) {
                return githubService.getFileContent(repositoryDTO, fileName, githubToken);
            } else {
                return gitLabService.getFileContent(repositoryDTO, fileName, gitlabToken);
            }
        } catch (Exception e) {
            log.debug("{} not found or error reading it", fileName, e);
            return null;
        }
    }
    
    private List<RepositoryFile> getRepositoryFiles(RepositoryDTO repositoryDTO, String githubToken, String gitlabToken) {
        if ("github".equalsIgnoreCase(repositoryDTO.getPlatform())) {
            return githubService.getRepositoryFiles(repositoryDTO, githubToken);
        } else {
            return gitLabService.getRepositoryFiles(repositoryDTO, gitlabToken);
        }
    }
    
    private List<Vulnerability> scanForCodeVulnerabilities(
            RepositoryDTO repositoryDTO,
            String githubToken,
            String gitlabToken
    ) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            // Get repository files for code analysis (with timeout protection)
            List<RepositoryFile> files = getRepositoryFiles(repositoryDTO, githubToken, gitlabToken);
            
            // Limit files to scan to prevent hanging (reduced for speed)
            int maxFilesToScan = 20; // Reduced from 30 for faster scanning
            int scannedCount = 0;
            
            // Scan each file for security vulnerabilities with timeout protection
            for (RepositoryFile file : files) {
                if (scannedCount >= maxFilesToScan) {
                    log.debug("Reached code vulnerability scan limit ({}), stopping", maxFilesToScan);
                    break;
                }
                
                // Skip documentation, examples, and non-code files
                String filePath = file.path().toLowerCase();
                if (filePath.endsWith(".md") || filePath.endsWith(".txt") || 
                    filePath.endsWith(".example") || filePath.endsWith(".sample") ||
                    filePath.contains(".env.example") || filePath.contains("readme") ||
                    filePath.contains("changelog") || filePath.contains("license") ||
                    filePath.contains("contributing") || filePath.contains("docs/") ||
                    filePath.contains("/examples/") || filePath.contains("/test/") ||
                    filePath.contains("/tests/") || filePath.contains("/spec/")) {
                    continue;
                }
                
                if (shouldScanFile(file.path())) {
                    try {
                        // Skip very large files
                        if (file.content() != null && file.content().length() > 500 * 1024) {
                            log.debug("Skipping large file for vulnerability scan: {}", file.path());
                            continue;
                        }
                        vulnerabilities.addAll(scanFileForVulnerabilities(file));
                        scannedCount++;
                    } catch (Exception e) {
                        log.debug("Error scanning file {} for vulnerabilities: {}", file.path(), e.getMessage());
                        // Continue with next file
                    }
                }
            }
            
            log.info("Scanned {} files for vulnerabilities, found {} total", scannedCount, vulnerabilities.size());
            
        } catch (Exception e) {
            log.error("Error scanning code for vulnerabilities", e);
        }
        
        return vulnerabilities;
    }
    
    private boolean shouldScanFile(String filePath) {
        // Only scan code files
        String lowerPath = filePath.toLowerCase();
        return lowerPath.endsWith(".js") || lowerPath.endsWith(".ts") || 
               lowerPath.endsWith(".java") || lowerPath.endsWith(".py") ||
               lowerPath.endsWith(".php") || lowerPath.endsWith(".rb") ||
               lowerPath.endsWith(".go") || lowerPath.endsWith(".rs") ||
               lowerPath.endsWith(".cs") || lowerPath.endsWith(".cpp") ||
               lowerPath.endsWith(".c") || lowerPath.endsWith(".h");
    }
    
    private List<Vulnerability> scanFileForVulnerabilities(RepositoryFile file) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        String content = file.content();
        
        if (content == null || content.isEmpty()) {
            return vulnerabilities;
        }
        
        String[] lines = content.split("\n");
        int lineNumber = 1;
        boolean previousLineWasAnnotation = false;
        
        for (String line : lines) {
            // Track if previous line was an annotation
            boolean currentLineIsAnnotation = line.trim().startsWith("@");
            
            // If previous line was annotation, skip this line (annotation parameters)
            if (previousLineWasAnnotation && (line.trim().startsWith("(") || 
                line.contains("name =") || line.contains("table =") || 
                line.contains("column =") || line.contains("nullable =") ||
                line.contains("length =") || line.contains("fetch =") ||
                line.contains("cascade =") || line.contains("mappedby ="))) {
                previousLineWasAnnotation = currentLineIsAnnotation;
                lineNumber++;
                continue;
            }
            
            previousLineWasAnnotation = currentLineIsAnnotation;
            // SQL Injection patterns
            if (isSqlInjectionVulnerable(line)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Potential SQL Injection");
                vuln.setDescription("String concatenation in SQL query detected. Use parameterized queries instead.");
                vuln.setSeverity(Vulnerability.Severity.HIGH);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-89");
                vulnerabilities.add(vuln);
            }
            
            // XSS patterns
            if (isXssVulnerable(line)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Potential Cross-Site Scripting (XSS)");
                vuln.setDescription("Unescaped user input in HTML output detected. Sanitize user input before rendering.");
                vuln.setSeverity(Vulnerability.Severity.HIGH);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-79");
                vulnerabilities.add(vuln);
            }
            
            // Command Injection patterns
            if (isCommandInjectionVulnerable(line)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Potential Command Injection");
                vuln.setDescription("User input used in system commands. Validate and sanitize input before execution.");
                vuln.setSeverity(Vulnerability.Severity.CRITICAL);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-78");
                vulnerabilities.add(vuln);
            }
            
            // Hardcoded secrets (complement to SecretScannerService)
            if (isHardcodedSecret(line, file.path(), lineNumber)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Hardcoded Credential");
                vuln.setDescription("Hardcoded password or credential detected. Use environment variables or secure storage.");
                vuln.setSeverity(Vulnerability.Severity.HIGH);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-798");
                vulnerabilities.add(vuln);
            }
            
            // Insecure random number generation
            if (isInsecureRandom(line)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Insecure Random Number Generation");
                vuln.setDescription("Using insecure random number generator. Use cryptographically secure random generators.");
                vuln.setSeverity(Vulnerability.Severity.MEDIUM);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-330");
                vulnerabilities.add(vuln);
            }
            
            // Weak cryptography
            if (isWeakCryptography(line)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Weak Cryptographic Algorithm");
                vuln.setDescription("Using deprecated or weak cryptographic algorithm. Use modern, secure algorithms.");
                vuln.setSeverity(Vulnerability.Severity.HIGH);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-327");
                vulnerabilities.add(vuln);
            }
            
            lineNumber++;
        }
        
        return vulnerabilities;
    }
    
    private boolean isSqlInjectionVulnerable(String line) {
        String lowerLine = line.toLowerCase();
        // Check for string concatenation in SQL queries
        return (lowerLine.contains("select") || lowerLine.contains("insert") || 
                lowerLine.contains("update") || lowerLine.contains("delete")) &&
               (lowerLine.contains("+") || lowerLine.contains("concat") || 
                lowerLine.contains("$") || lowerLine.contains("${")) &&
               (lowerLine.contains("request") || lowerLine.contains("req.") || 
                lowerLine.contains("params") || lowerLine.contains("query") ||
                lowerLine.contains("body") || lowerLine.contains("input"));
    }
    
    private boolean isXssVulnerable(String line) {
        String lowerLine = line.toLowerCase();
        // Check for unescaped user input in HTML
        return (lowerLine.contains("innerhtml") || lowerLine.contains("innerhtml") ||
                lowerLine.contains("document.write") || lowerLine.contains("eval(")) &&
               (lowerLine.contains("request") || lowerLine.contains("req.") ||
                lowerLine.contains("params") || lowerLine.contains("query") ||
                lowerLine.contains("body") || lowerLine.contains("input") ||
                lowerLine.contains("user") || lowerLine.contains("data"));
    }
    
    private boolean isCommandInjectionVulnerable(String line) {
        String lowerLine = line.toLowerCase();
        // Check for user input in system commands
        return (lowerLine.contains("exec(") || lowerLine.contains("system(") ||
                lowerLine.contains("runtime.exec") || lowerLine.contains("process.exec") ||
                lowerLine.contains("child_process") || lowerLine.contains("os.system") ||
                lowerLine.contains("subprocess") || lowerLine.contains("shell_exec")) &&
               (lowerLine.contains("request") || lowerLine.contains("req.") ||
                lowerLine.contains("params") || lowerLine.contains("query") ||
                lowerLine.contains("body") || lowerLine.contains("input"));
    }
    
    private boolean isHardcodedSecret(String line, String filePath, int lineNumber) {
        String trimmedLine = line.trim();
        String lowerLine = trimmedLine.toLowerCase();
        
        // Skip comments
        if (trimmedLine.startsWith("//") || trimmedLine.startsWith("#") || 
            trimmedLine.startsWith("/*") || trimmedLine.startsWith("*") ||
            trimmedLine.startsWith("<!--") || trimmedLine.startsWith("--")) {
            return false;
        }
        
        // Skip annotations (JPA, Spring, etc.) - they often contain "secret" in table/column names
        // Check if line starts with @ or contains annotation patterns
        if (trimmedLine.startsWith("@") || 
            lowerLine.contains("@table") || lowerLine.contains("@column") || 
            lowerLine.contains("@entity") || lowerLine.contains("@manytoone") || 
            lowerLine.contains("@onetomany") || lowerLine.contains("@joincolumn") || 
            lowerLine.contains("@index") || lowerLine.contains("@id") ||
            lowerLine.contains("@generatedvalue") || lowerLine.contains("@enumerated")) {
            return false;
        }
        
        // CRITICAL: Skip ALL lines with annotation parameters FIRST
        // These are database schema definitions, NOT credential assignments
        // Pattern: name = "value", table = "value", column = "value", etc.
        // Check this BEFORE any other password/secret checks
        if (lowerLine.matches(".*\\b(name|table|column|nullable|length|fetch|cascade|mappedby|strategy|columnlist)\\s*=\\s*[\"'].*") ||
            lowerLine.contains("name =") || lowerLine.contains("table =") || 
            lowerLine.contains("column =") || lowerLine.contains("nullable =") ||
            lowerLine.contains("length =") || lowerLine.contains("fetch =") ||
            lowerLine.contains("cascade =") || lowerLine.contains("mappedby =") ||
            lowerLine.contains("columnlist =") || lowerLine.contains("strategy =")) {
            return false;
        }
        
        // Skip variable/field declarations without assignment (e.g., "private List<SecretLeak> secrets;")
        if ((lowerLine.contains("private") || lowerLine.contains("public") || 
             lowerLine.contains("protected") || lowerLine.contains("static") ||
             lowerLine.contains("final") || lowerLine.contains("var") ||
             lowerLine.contains("let") || lowerLine.contains("const") ||
             lowerLine.contains("List<") || lowerLine.contains("Set<") ||
             lowerLine.contains("Map<")) &&
            (lowerLine.contains("secret") || lowerLine.contains("password")) &&
            !lowerLine.contains("=") && !lowerLine.contains(":")) {
            return false;
        }
        
        // Skip documentation/examples - expanded list (check entire line first)
        if (lowerLine.contains("example") || lowerLine.contains("example.com") ||
            lowerLine.contains("test") || lowerLine.contains("demo") ||
            lowerLine.contains("sample") || lowerLine.contains("placeholder") ||
            lowerLine.contains("your_") || lowerLine.contains("change_") ||
            lowerLine.contains("todo") || lowerLine.contains("fixme") ||
            lowerLine.contains("your_secure_password") || lowerLine.contains("secure_password_here") ||
            lowerLine.contains("replace_") || lowerLine.contains("set_") ||
            lowerLine.contains("update_") || lowerLine.contains("configure_") ||
            lowerLine.contains("fill_") || lowerLine.contains("enter_") ||
            lowerLine.contains("add_") || lowerLine.contains("insert_") ||
            lowerLine.contains("```") || lowerLine.contains("bash") ||
            lowerLine.contains("code") || lowerLine.contains("yaml") ||
            lowerLine.contains("json") || lowerLine.contains("xml")) {
            return false;
        }
        
        // Skip if already using environment variables or configuration
        if (lowerLine.contains("env") || lowerLine.contains("process.env") ||
            lowerLine.contains("getenv") || lowerLine.contains("system.getenv") ||
            lowerLine.contains("config") || lowerLine.contains("properties") ||
            lowerLine.contains("${") || lowerLine.contains("$env:") ||
            lowerLine.contains("environment") || lowerLine.contains("os.getenv")) {
            return false;
        }
        
        // Skip if it's a variable declaration without assignment
        if (lowerLine.contains("password") || lowerLine.contains("secret") || 
            lowerLine.contains("api_key") || lowerLine.contains("api-key")) {
            
            // CRITICAL: Skip annotation parameters BEFORE checking assignments
            // These patterns indicate annotation parameters, NOT credential assignments
            if (lowerLine.matches(".*\\b(name|table|column|nullable|length|fetch|cascade|mappedby|strategy|columnlist)\\s*=\\s*[\"'].*") ||
                lowerLine.contains("name =") || lowerLine.contains("table =") || 
                lowerLine.contains("column =") || lowerLine.contains("nullable =") ||
                lowerLine.contains("length =") || lowerLine.contains("fetch =") ||
                lowerLine.contains("cascade =") || lowerLine.contains("mappedby =") ||
                lowerLine.contains("columnlist =") || lowerLine.contains("strategy =")) {
                return false;
            }
            
            // Check if there's an actual assignment with a value
            if (lowerLine.contains("=") || lowerLine.contains(":")) {
                // Extract the value part
                String valuePart = "";
                if (lowerLine.contains("=")) {
                    int eqIndex = lowerLine.indexOf("=");
                    valuePart = lowerLine.substring(eqIndex + 1).trim();
                } else if (lowerLine.contains(":")) {
                    int colonIndex = lowerLine.indexOf(":");
                    valuePart = lowerLine.substring(colonIndex + 1).trim();
                }
                
                // Remove quotes
                valuePart = valuePart.replaceAll("^[\"']+|[\"']+$", "");
                valuePart = valuePart.trim();
                String lowerValuePart = valuePart.toLowerCase();
                
                // Skip if empty, null, undefined, or placeholder values
                if (valuePart.isEmpty() || valuePart.equals("null") || 
                    valuePart.equals("undefined") || valuePart.equals("none") ||
                    valuePart.equals("''") || valuePart.equals("\"\"")) {
                    return false;
                }
                
                // Skip if it's a variable reference (starts with $, @, or is a variable name)
                if (valuePart.startsWith("$") || valuePart.startsWith("@") ||
                    valuePart.matches("^[a-zA-Z_][a-zA-Z0-9_]*$")) {
                    return false;
                }
                
                // Skip if it's a function call or method
                if (valuePart.contains("(") || valuePart.contains("get") ||
                    valuePart.contains("read") || valuePart.contains("load")) {
                    return false;
                }
                
                // Skip common example/placeholder patterns in the value itself
                if (lowerValuePart.contains("example") || lowerValuePart.contains("test") ||
                    lowerValuePart.contains("demo") || lowerValuePart.contains("sample") ||
                    lowerValuePart.contains("placeholder") || lowerValuePart.contains("your_") ||
                    lowerValuePart.contains("change_") || lowerValuePart.contains("todo") ||
                    lowerValuePart.contains("fixme") || lowerValuePart.contains("secure_password_here") ||
                    lowerValuePart.contains("replace") || lowerValuePart.contains("set_") ||
                    lowerValuePart.contains("update_") || lowerValuePart.contains("configure") ||
                    lowerValuePart.contains("fill") || lowerValuePart.contains("enter") ||
                    lowerValuePart.contains("add_") || lowerValuePart.contains("insert") ||
                    lowerValuePart.matches(".*(xxx|xxx+|xxxx+|xxxxx+).*") ||
                    lowerValuePart.equals("password") || lowerValuePart.equals("secret") ||
                    lowerValuePart.startsWith("your") || lowerValuePart.startsWith("change") ||
                    lowerValuePart.startsWith("replace") || lowerValuePart.startsWith("set") ||
                    lowerValuePart.startsWith("update") || lowerValuePart.startsWith("configure")) { // Skip xxxx patterns
                    return false;
                }
                
                // Only flag if it looks like a real hardcoded value (has quotes and actual content)
                // AND it's not a common pattern
                if ((lowerLine.contains("\"") || lowerLine.contains("'")) &&
                    valuePart.length() >= 8) { // Minimum length for a real credential
                    // Check if it's a placeholder/example value
                    boolean isPlaceholder = lowerValuePart.matches(".*(example|test|demo|sample|placeholder|your|change|todo|fixme|secure_password|replace|set|update|configure|fill|enter|add|insert|xxx|password|secret).*");
                    
                    if (!isPlaceholder) {
                        // Additional check: if it's a simple lowercase string without numbers/special chars, 
                        // it's likely not a real credential (most credentials have complexity)
                        boolean hasComplexity = valuePart.matches(".*[A-Z].*") || 
                                               valuePart.matches(".*[0-9].*") || 
                                               valuePart.matches(".*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>/?].*");
                        
                        if (hasComplexity || valuePart.length() >= 16) {
                            // Has complexity or is long enough - likely a real credential
                            log.warn("HARDCODED CREDENTIAL DETECTED in {}:{} - Value: {}", 
                                    filePath, lineNumber, valuePart.substring(0, Math.min(20, valuePart.length())));
                            return true;
                        } else {
                            log.debug("Skipped simple value in {}:{} - Value: {} (likely not a credential)", 
                                    filePath, lineNumber, valuePart.substring(0, Math.min(20, valuePart.length())));
                        }
                    } else {
                        log.debug("Skipped placeholder value in {}:{} - Value: {}", 
                                filePath, lineNumber, valuePart.substring(0, Math.min(20, valuePart.length())));
                    }
                }
            }
        }
        
        return false;
    }
    
    private boolean isInsecureRandom(String line) {
        String lowerLine = line.toLowerCase();
        // Check for insecure random number generators
        return (lowerLine.contains("math.random") || lowerLine.contains("random()") ||
                lowerLine.contains("new random()") || lowerLine.contains("rand()")) &&
               !lowerLine.contains("secure") && !lowerLine.contains("crypto");
    }
    
    private boolean isWeakCryptography(String line) {
        String lowerLine = line.toLowerCase();
        // Check for weak cryptographic algorithms
        return (lowerLine.contains("md5") || lowerLine.contains("sha1") ||
                lowerLine.contains("des") || lowerLine.contains("rc4")) &&
               (lowerLine.contains("hash") || lowerLine.contains("encrypt") ||
                lowerLine.contains("cipher") || lowerLine.contains("digest"));
    }
}
