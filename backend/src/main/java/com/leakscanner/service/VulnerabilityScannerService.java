package com.leakscanner.service;

import com.leakscanner.dto.RepositoryDTO;
import com.leakscanner.model.Vulnerability;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class VulnerabilityScannerService {
    
    private final GitHubService githubService;
    private final GitLabService gitLabService;
    private final NpmAuditService npmAuditService;
    private final SnykService snykService;
    
    @Value("${leakscanner.api.snyk.base-url:https://api.snyk.io/v1}")
    private String snykBaseUrl;
    
    public List<Vulnerability> scanForVulnerabilities(
            RepositoryDTO repositoryDTO,
            String githubToken,
            String gitlabToken,
            String snykToken
    ) {
        log.info("Scanning for vulnerabilities in {}: {}/{}", 
                repositoryDTO.getPlatform(), repositoryDTO.getOwner(), repositoryDTO.getName());
        
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            // Get package.json, pom.xml, or requirements.txt
            String packageJson = getPackageFileContent(repositoryDTO, "package.json", githubToken, gitlabToken);
            getPackageFileContent(repositoryDTO, "pom.xml", githubToken, gitlabToken); // Check for Maven projects
            getPackageFileContent(repositoryDTO, "requirements.txt", githubToken, gitlabToken); // Check for Python projects
            
            // Scan with npm audit
            if (packageJson != null) {
                vulnerabilities.addAll(npmAuditService.scanPackageJson(packageJson));
            }
            
            // Scan with Snyk if token provided
            if (snykToken != null && !snykToken.isEmpty()) {
                vulnerabilities.addAll(snykService.scanRepository(repositoryDTO, snykToken));
            }
            
            // Check for common security issues in code
            vulnerabilities.addAll(scanForCodeVulnerabilities(repositoryDTO, githubToken, gitlabToken));
            
        } catch (Exception e) {
            log.error("Error scanning for vulnerabilities", e);
        }
        
        return vulnerabilities;
    }
    
    private String getPackageFileContent(RepositoryDTO repositoryDTO, String fileName, String githubToken, String gitlabToken) {
        try {
            if ("github".equalsIgnoreCase(repositoryDTO.getPlatform())) {
                return githubService.getFileContent(repositoryDTO, fileName, githubToken);
            } else {
                return gitLabService.getFileContent(repositoryDTO, fileName, gitlabToken);
            }
        } catch (Exception e) {
            log.debug("{} not found or error reading it", fileName, e);
            return null;
        }
    }
    
    private List<RepositoryFile> getRepositoryFiles(RepositoryDTO repositoryDTO, String githubToken, String gitlabToken) {
        if ("github".equalsIgnoreCase(repositoryDTO.getPlatform())) {
            return githubService.getRepositoryFiles(repositoryDTO, githubToken);
        } else {
            return gitLabService.getRepositoryFiles(repositoryDTO, gitlabToken);
        }
    }
    
    private List<Vulnerability> scanForCodeVulnerabilities(
            RepositoryDTO repositoryDTO,
            String githubToken,
            String gitlabToken
    ) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            // Get repository files for code analysis (with timeout protection)
            List<RepositoryFile> files = getRepositoryFiles(repositoryDTO, githubToken, gitlabToken);
            
            // Limit files to scan to prevent hanging
            int maxFilesToScan = 30;
            int scannedCount = 0;
            
            // Scan each file for security vulnerabilities
            for (RepositoryFile file : files) {
                if (scannedCount >= maxFilesToScan) {
                    log.warn("Reached code vulnerability scan limit ({}), stopping", maxFilesToScan);
                    break;
                }
                
                if (shouldScanFile(file.path())) {
                    try {
                        vulnerabilities.addAll(scanFileForVulnerabilities(file));
                        scannedCount++;
                    } catch (Exception e) {
                        log.warn("Error scanning file {} for vulnerabilities: {}", file.path(), e.getMessage());
                        // Continue with next file
                    }
                }
            }
            
        } catch (Exception e) {
            log.error("Error scanning code for vulnerabilities", e);
        }
        
        return vulnerabilities;
    }
    
    private boolean shouldScanFile(String filePath) {
        // Only scan code files
        String lowerPath = filePath.toLowerCase();
        return lowerPath.endsWith(".js") || lowerPath.endsWith(".ts") || 
               lowerPath.endsWith(".java") || lowerPath.endsWith(".py") ||
               lowerPath.endsWith(".php") || lowerPath.endsWith(".rb") ||
               lowerPath.endsWith(".go") || lowerPath.endsWith(".rs") ||
               lowerPath.endsWith(".cs") || lowerPath.endsWith(".cpp") ||
               lowerPath.endsWith(".c") || lowerPath.endsWith(".h");
    }
    
    private List<Vulnerability> scanFileForVulnerabilities(RepositoryFile file) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        String content = file.content();
        
        if (content == null || content.isEmpty()) {
            return vulnerabilities;
        }
        
        String[] lines = content.split("\n");
        
        for (String line : lines) {
            // SQL Injection patterns
            if (isSqlInjectionVulnerable(line)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Potential SQL Injection");
                vuln.setDescription("String concatenation in SQL query detected. Use parameterized queries instead.");
                vuln.setSeverity(Vulnerability.Severity.HIGH);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-89");
                vulnerabilities.add(vuln);
            }
            
            // XSS patterns
            if (isXssVulnerable(line)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Potential Cross-Site Scripting (XSS)");
                vuln.setDescription("Unescaped user input in HTML output detected. Sanitize user input before rendering.");
                vuln.setSeverity(Vulnerability.Severity.HIGH);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-79");
                vulnerabilities.add(vuln);
            }
            
            // Command Injection patterns
            if (isCommandInjectionVulnerable(line)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Potential Command Injection");
                vuln.setDescription("User input used in system commands. Validate and sanitize input before execution.");
                vuln.setSeverity(Vulnerability.Severity.CRITICAL);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-78");
                vulnerabilities.add(vuln);
            }
            
            // Hardcoded secrets (complement to SecretScannerService)
            if (isHardcodedSecret(line)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Hardcoded Credential");
                vuln.setDescription("Hardcoded password or credential detected. Use environment variables or secure storage.");
                vuln.setSeverity(Vulnerability.Severity.HIGH);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-798");
                vulnerabilities.add(vuln);
            }
            
            // Insecure random number generation
            if (isInsecureRandom(line)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Insecure Random Number Generation");
                vuln.setDescription("Using insecure random number generator. Use cryptographically secure random generators.");
                vuln.setSeverity(Vulnerability.Severity.MEDIUM);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-330");
                vulnerabilities.add(vuln);
            }
            
            // Weak cryptography
            if (isWeakCryptography(line)) {
                Vulnerability vuln = new Vulnerability();
                vuln.setTitle("Weak Cryptographic Algorithm");
                vuln.setDescription("Using deprecated or weak cryptographic algorithm. Use modern, secure algorithms.");
                vuln.setSeverity(Vulnerability.Severity.HIGH);
                vuln.setPackageName(file.path());
                vuln.setCve("CWE-327");
                vulnerabilities.add(vuln);
            }
        }
        
        return vulnerabilities;
    }
    
    private boolean isSqlInjectionVulnerable(String line) {
        String lowerLine = line.toLowerCase();
        // Check for string concatenation in SQL queries
        return (lowerLine.contains("select") || lowerLine.contains("insert") || 
                lowerLine.contains("update") || lowerLine.contains("delete")) &&
               (lowerLine.contains("+") || lowerLine.contains("concat") || 
                lowerLine.contains("$") || lowerLine.contains("${")) &&
               (lowerLine.contains("request") || lowerLine.contains("req.") || 
                lowerLine.contains("params") || lowerLine.contains("query") ||
                lowerLine.contains("body") || lowerLine.contains("input"));
    }
    
    private boolean isXssVulnerable(String line) {
        String lowerLine = line.toLowerCase();
        // Check for unescaped user input in HTML
        return (lowerLine.contains("innerhtml") || lowerLine.contains("innerhtml") ||
                lowerLine.contains("document.write") || lowerLine.contains("eval(")) &&
               (lowerLine.contains("request") || lowerLine.contains("req.") ||
                lowerLine.contains("params") || lowerLine.contains("query") ||
                lowerLine.contains("body") || lowerLine.contains("input") ||
                lowerLine.contains("user") || lowerLine.contains("data"));
    }
    
    private boolean isCommandInjectionVulnerable(String line) {
        String lowerLine = line.toLowerCase();
        // Check for user input in system commands
        return (lowerLine.contains("exec(") || lowerLine.contains("system(") ||
                lowerLine.contains("runtime.exec") || lowerLine.contains("process.exec") ||
                lowerLine.contains("child_process") || lowerLine.contains("os.system") ||
                lowerLine.contains("subprocess") || lowerLine.contains("shell_exec")) &&
               (lowerLine.contains("request") || lowerLine.contains("req.") ||
                lowerLine.contains("params") || lowerLine.contains("query") ||
                lowerLine.contains("body") || lowerLine.contains("input"));
    }
    
    private boolean isHardcodedSecret(String line) {
        String lowerLine = line.toLowerCase();
        // Check for hardcoded passwords
        return (lowerLine.contains("password") || lowerLine.contains("passwd") ||
                lowerLine.contains("secret") || lowerLine.contains("api_key")) &&
               (lowerLine.contains("=") || lowerLine.contains(":")) &&
               !lowerLine.contains("env") && !lowerLine.contains("process.env") &&
               !lowerLine.contains("getenv") && !lowerLine.contains("config") &&
               (lowerLine.contains("\"") || lowerLine.contains("'"));
    }
    
    private boolean isInsecureRandom(String line) {
        String lowerLine = line.toLowerCase();
        // Check for insecure random number generators
        return (lowerLine.contains("math.random") || lowerLine.contains("random()") ||
                lowerLine.contains("new random()") || lowerLine.contains("rand()")) &&
               !lowerLine.contains("secure") && !lowerLine.contains("crypto");
    }
    
    private boolean isWeakCryptography(String line) {
        String lowerLine = line.toLowerCase();
        // Check for weak cryptographic algorithms
        return (lowerLine.contains("md5") || lowerLine.contains("sha1") ||
                lowerLine.contains("des") || lowerLine.contains("rc4")) &&
               (lowerLine.contains("hash") || lowerLine.contains("encrypt") ||
                lowerLine.contains("cipher") || lowerLine.contains("digest"));
    }
}
