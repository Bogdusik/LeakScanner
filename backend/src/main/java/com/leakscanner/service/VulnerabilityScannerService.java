package com.leakscanner.service;

import com.leakscanner.dto.RepositoryDTO;
import com.leakscanner.model.Vulnerability;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.ArrayList;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class VulnerabilityScannerService {
    
    private final WebClient.Builder webClientBuilder;
    private final GitHubService githubService;
    private final GitLabService gitLabService;
    private final NpmAuditService npmAuditService;
    private final SnykService snykService;
    
    @Value("${leakscanner.api.snyk.base-url:https://api.snyk.io/v1}")
    private String snykBaseUrl;
    
    public List<Vulnerability> scanForVulnerabilities(
            RepositoryDTO repositoryDTO,
            String githubToken,
            String gitlabToken,
            String snykToken
    ) {
        log.info("Scanning for vulnerabilities in {}: {}/{}", 
                repositoryDTO.getPlatform(), repositoryDTO.getOwner(), repositoryDTO.getName());
        
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            // Get package.json or pom.xml
            String packageFile = getPackageFile(repositoryDTO, githubToken, gitlabToken);
            
            if (packageFile != null) {
                // Scan with npm audit
                if (packageFile.contains("package.json")) {
                    vulnerabilities.addAll(npmAuditService.scanPackageJson(packageFile));
                }
                
                // Scan with Snyk if token provided
                if (snykToken != null && !snykToken.isEmpty()) {
                    vulnerabilities.addAll(snykService.scanRepository(repositoryDTO, snykToken));
                }
            }
            
            // Check for common security issues in code
            vulnerabilities.addAll(scanForCodeVulnerabilities(repositoryDTO, githubToken, gitlabToken));
            
        } catch (Exception e) {
            log.error("Error scanning for vulnerabilities", e);
        }
        
        return vulnerabilities;
    }
    
    private String getPackageFile(RepositoryDTO repositoryDTO, String githubToken, String gitlabToken) {
        if ("github".equalsIgnoreCase(repositoryDTO.getPlatform())) {
            return githubService.getFileContent(repositoryDTO, "package.json", githubToken);
        } else {
            return gitLabService.getFileContent(repositoryDTO, "package.json", gitlabToken);
        }
    }
    
    private List<Vulnerability> scanForCodeVulnerabilities(
            RepositoryDTO repositoryDTO,
            String githubToken,
            String gitlabToken
    ) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        // Common security patterns
        // SQL Injection
        Vulnerability sqlInjection = new Vulnerability();
        sqlInjection.setTitle("Potential SQL Injection");
        sqlInjection.setDescription("Code may be vulnerable to SQL injection attacks");
        sqlInjection.setSeverity(Vulnerability.Severity.HIGH);
        // This would be enhanced with actual code scanning
        
        return vulnerabilities;
    }
}
